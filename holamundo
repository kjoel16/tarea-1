using System.Net.Http.Json;
using System.Text.Json;

public interface IAuthService
{
    Task<TokenResponse> ObtenerTokenAsync();
}

public sealed class AuthService : IAuthService
{
    private readonly IHttpClientFactory _factory;
    private readonly IConfiguration _cfg;

    public AuthService(IHttpClientFactory factory, IConfiguration cfg)
    {
        _factory = factory;
        _cfg = cfg;
    }

    public async Task<TokenResponse> ObtenerTokenAsync()
    {
        var client = _factory.CreateClient("mtls");
        var url = _cfg["TokenEndpoint"]!;

        // Ajusta el payload al que exige tu endpoint
        var payload = new
        {
            client_id = "TU_CLIENT_ID",
            client_secret = "TU_CLIENT_SECRET",
            grant_type = "client_credentials",
            scope = "api.read"
        };

        // A) JSON (si lo acepta)
        var resp = await client.PostAsJsonAsync(url, payload);

        // B) Si el servidor exige x-www-form-urlencoded, usa:
        // var form = new FormUrlEncodedContent(new[]
        // {
        //     new KeyValuePair<string,string>("client_id","TU_CLIENT_ID"),
        //     new KeyValuePair<string,string>("client_secret","TU_CLIENT_SECRET"),
        //     new KeyValuePair<string,string>("grant_type","client_credentials"),
        //     new KeyValuePair<string,string>("scope","api.read")
        // });
        // var resp = await client.PostAsync(url, form);

        resp.EnsureSuccessStatusCode();

        var json = await resp.Content.ReadAsStringAsync();
        return JsonSerializer.Deserialize<TokenResponse>(
            json, new JsonSerializerOptions { PropertyNameCaseInsensitive = true })!;
    }
}

public sealed class TokenResponse
{
    public string? Access_Token { get; set; }
    public string? Token_Type { get; set; }
    public int Expires_In { get; set; }
    // agrega otros campos si el proveedor los devuelve
}
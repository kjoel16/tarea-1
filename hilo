H DFTACTGRP(*NO) ACTGRP(*CALLER) OPTION(*SRCSTMT)

F* Cambia DINO por tu DSPF
FDINO      CF   E             WORKSTN

D Board           S              1A   DIM(200)
D Scr             S             20A   DIM(20)

D CurPiece        S              3S 0
D CurRot          S              3S 0  /* 1..4 */
D CurRow          S              3S 0
D CurCol          S              3S 0

D LinesCnt        S              7S 0
D PointsCnt       S              9S 0
D LevelN          S              3S 0

D GameOver        S               N
D CanMove         S               N

D dx              S              3S 0
D dy              S              3S 0
D NewRot          S              3S 0

D r               S              5S 0
D c               S              5S 0
D rr              S              5S 0
D cc              S              5S 0
D i               S              5S 0
D idx             S              7S 0
D pos             S              7S 0

D Ppx             S              2S 0 DIM(112)
D Ppy             S              2S 0 DIM(112)

D Seed            S              9S 0
D tm              S              6S 0
D dt              S              6S 0

D ch2             S              2A
D MsgLocal        S             60A

 /free
   exsr LoadShapes;
   exsr InitGame;

   dou *in03;  // F3 salir

     exsr Render;
     write MAIN;
     read  MAIN;

     if *in04; // F4 nuevo
       exsr InitGame;
       iter;
     endif;

     if GameOver;
       MsgLocal = 'GAME OVER. F4=Nuevo / F3=Salir';
       iter;
     endif;

     dx = 0;
     dy = 1;         // Enter = baja 1
     NewRot = CurRot;

     if *in07;       // F7 rotar
       dy = 0;
       NewRot = CurRot + 1;
       if NewRot > 4;
         NewRot = 1;
       endif;
     elseif *in08;   // F8 izq
       dy = 0;
       dx = -1;
     elseif *in09;   // F9 der
       dy = 0;
       dx = 1;
     elseif *in10;   // F10 drop
       exsr HardDrop;
       iter;
     endif;

     exsr TryMove;

   enddo;

   *inlr = *on;
   return;
 /end-free


 /free
begsr InitGame;
  PointsCnt = 0;
  LinesCnt  = 0;
  LevelN    = 1;
  GameOver  = *off;
  MsgLocal  = 'Listo. Enter=baja  F7=rotar  F8=izq  F9=der  F10=drop';

  for i = 1 to 200;
    Board(i) = '0';
  endfor;

  exsr Spawn;
endsr;
 /end-free


 /free
begsr RandPiece;
  time tm;
  date dt;
  Seed = (dt * 1000000) + tm;
  if Seed < 0;
    Seed = -Seed;
  endif;
  CurPiece = %rem(Seed: 7) + 1;
endsr;
 /end-free


 /free
begsr Spawn;
  exsr RandPiece;
  CurRot = 1;
  CurRow = 1;
  CurCol = 4;

  dx = 0; dy = 0; NewRot = CurRot;
  exsr CanMoveSR;
  if not CanMove;
    GameOver = *on;
  endif;
endsr;
 /end-free


 /free
begsr GetBlock;
  // idx = ((piece-1)*16) + ((rot-1)*4) + block(1..4)
  // usa la variable i como block actual 1..4
  idx = ((CurPiece - 1) * 16) + ((NewRot - 1) * 4) + i;
endsr;
 /end-free


 /free
begsr CanMoveSR;
  CanMove = *on;

  for i = 1 to 4;
    exsr GetBlock;

    rr = CurRow + dy + Ppy(idx);
    cc = CurCol + dx + Ppx(idx);

    if (rr < 1) or (rr > 20) or (cc < 1) or (cc > 10);
      CanMove = *off;
      leave;
    endif;

    idx = (rr - 1) * 10 + cc;
    if Board(idx) = '1';
      CanMove = *off;
      leave;
    endif;
  endfor;
endsr;
 /end-free


 /free
begsr TryMove;
  exsr CanMoveSR;

  if CanMove;
    CurCol = CurCol + dx;
    CurRow = CurRow + dy;
    CurRot = NewRot;
  else;
    // si intentÃ³ bajar y no pudo => fijar pieza
    if dy = 1;
      exsr LockPiece;
      exsr ClearLines;
      exsr Spawn;
    endif;
  endif;
endsr;
 /end-free


 /free
begsr HardDrop;
  dou *in99; // loop infinito controlado con LEAVE
    dx = 0; dy = 1; NewRot = CurRot;
    exsr CanMoveSR;
    if CanMove;
      CurRow = CurRow + 1;
    else;
      leave;
    endif;
  enddo;

  exsr LockPiece;
  exsr ClearLines;
  exsr Spawn;
endsr;
 /end-free


 /free
begsr LockPiece;
  for i = 1 to 4;
    NewRot = CurRot;
    exsr GetBlock;

    rr = CurRow + Ppy(idx);
    cc = CurCol + Ppx(idx);

    if (rr >= 1) and (rr <= 20) and (cc >= 1) and (cc <= 10);
      idx = (rr - 1) * 10 + cc;
      Board(idx) = '1';
    endif;
  endfor;
endsr;
 /end-free


 /free
begsr ClearLines;
  for r = 20 downto 1;

    CanMove = *on; // reutilizo como "fila llena"
    for c = 1 to 10;
      idx = (r - 1) * 10 + c;
      if Board(idx) <> '1';
        CanMove = *off;
        leave;
      endif;
    endfor;

    if CanMove;
      // bajar filas
      for rr = r downto 2;
        for cc = 1 to 10;
          idx = (rr - 1) * 10 + cc;
          i   = (rr - 2) * 10 + cc;
          Board(idx) = Board(i);
        endfor;
      endfor;

      // limpiar fila 1
      for cc = 1 to 10;
        Board(cc) = '0';
      endfor;

      LinesCnt = LinesCnt + 1;
      PointsCnt = PointsCnt + 100;
      LevelN = (LinesCnt / 10) + 1;

      r = r + 1; // revisar la misma fila otra vez
    endif;

  endfor;
endsr;
 /end-free


 /free
begsr Render;
  // tablero fijo
  for r = 1 to 20;
    Scr(r) = *blanks;

    for c = 1 to 10;
      idx = (r - 1) * 10 + c;

      if Board(idx) = '1';
        ch2 = '[]';
      else;
        ch2 = '  ';
      endif;

      pos = (c - 1) * 2 + 1;
      %subst(Scr(r): pos: 2) = ch2;
    endfor;
  endfor;

  // overlay pieza actual
  NewRot = CurRot;
  for i = 1 to 4;
    exsr GetBlock;
    rr = CurRow + Ppy(idx);
    cc = CurCol + Ppx(idx);

    if (rr >= 1) and (rr <= 20) and (cc >= 1) and (cc <= 10);
      pos = (cc - 1) * 2 + 1;
      %subst(Scr(rr): pos: 2) = '##';
    endif;
  endfor;

  // mapear a pantalla
  B01 = Scr(1);  B02 = Scr(2);  B03 = Scr(3);  B04 = Scr(4);  B05 = Scr(5);
  B06 = Scr(6);  B07 = Scr(7);  B08 = Scr(8);  B09 = Scr(9);  B10 = Scr(10);
  B11 = Scr(11); B12 = Scr(12); B13 = Scr(13); B14 = Scr(14); B15 = Scr(15);
  B16 = Scr(16); B17 = Scr(17); B18 = Scr(18); B19 = Scr(19); B20 = Scr(20);

  MSG   = MsgLocal;
  SCORE = %char(PointsCnt);
  LINES = %char(LinesCnt);
  LEVEL = %char(LevelN);
endsr;
 /end-free


 /free
begsr LoadShapes;
  // Igual que el set que ya te funcionaba antes (112 entradas por array)
  // PIEZA 1: I
  Ppx(  1)=0; Ppy(  1)=1;  Ppx(  2)=1; Ppy(  2)=1;  Ppx(  3)=2; Ppy(  3)=1;  Ppx(  4)=3; Ppy(  4)=1;
  Ppx(  5)=1; Ppy(  5)=0;  Ppx(  6)=1; Ppy(  6)=1;  Ppx(  7)=1; Ppy(  7)=2;  Ppx(  8)=1; Ppy(  8)=3;
  Ppx(  9)=0; Ppy(  9)=1;  Ppx( 10)=1; Ppy( 10)=1;  Ppx( 11)=2; Ppy( 11)=1;  Ppx( 12)=3; Ppy( 12)=1;
  Ppx( 13)=1; Ppy( 13)=0;  Ppx( 14)=1; Ppy( 14)=1;  Ppx( 15)=1; Ppy( 15)=2;  Ppx( 16)=1; Ppy( 16)=3;

  // PIEZA 2: O
  Ppx( 17)=1; Ppy( 17)=1;  Ppx( 18)=2; Ppy( 18)=1;  Ppx( 19)=1; Ppy( 19)=2;  Ppx( 20)=2; Ppy( 20)=2;
  Ppx( 21)=1; Ppy( 21)=1;  Ppx( 22)=2; Ppy( 22)=1;  Ppx( 23)=1; Ppy( 23)=2;  Ppx( 24)=2; Ppy( 24)=2;
  Ppx( 25)=1; Ppy( 25)=1;  Ppx( 26)=2; Ppy( 26)=1;  Ppx( 27)=1; Ppy( 27)=2;  Ppx( 28)=2; Ppy( 28)=2;
  Ppx( 29)=1; Ppy( 29)=1;  Ppx( 30)=2; Ppy( 30)=1;  Ppx( 31)=1; Ppy( 31)=2;  Ppx( 32)=2; Ppy( 32)=2;

  // PIEZA 3: T
  Ppx( 33)=1; Ppy( 33)=1;  Ppx( 34)=0; Ppy( 34)=2;  Ppx( 35)=1; Ppy( 35)=2;  Ppx( 36)=2; Ppy( 36)=2;
  Ppx( 37)=1; Ppy( 37)=1;  Ppx( 38)=1; Ppy( 38)=2;  Ppx( 39)=2; Ppy( 39)=2;  Ppx( 40)=1; Ppy( 40)=3;
  Ppx( 41)=0; Ppy( 41)=2;  Ppx( 42)=1; Ppy( 42)=2;  Ppx( 43)=2; Ppy( 43)=2;  Ppx( 44)=1; Ppy( 44)=3;
  Ppx( 45)=1; Ppy( 45)=1;  Ppx( 46)=0; Ppy( 46)=2;  Ppx( 47)=1; Ppy( 47)=2;  Ppx( 48)=1; Ppy( 48)=3;

  // PIEZA 4: S
  Ppx( 49)=1; Ppy( 49)=1;  Ppx( 50)=2; Ppy( 50)=1;  Ppx( 51)=0; Ppy( 51)=2;  Ppx( 52)=1; Ppy( 52)=2;
  Ppx( 53)=1; Ppy( 53)=0;  Ppx( 54)=1; Ppy( 54)=1;  Ppx( 55)=2; Ppy( 55)=1;  Ppx( 56)=2; Ppy( 56)=2;
  Ppx( 57)=1; Ppy( 57)=1;  Ppx( 58)=2; Ppy( 58)=1;  Ppx( 59)=0; Ppy( 59)=2;  Ppx( 60)=1; Ppy( 60)=2;
  Ppx( 61)=1; Ppy( 61)=0;  Ppx( 62)=1; Ppy( 62)=1;  Ppx( 63)=2; Ppy( 63)=1;  Ppx( 64)=2; Ppy( 64)=2;

  // PIEZA 5: Z
  Ppx( 65)=0; Ppy( 65)=1;  Ppx( 66)=1; Ppy( 66)=1;  Ppx( 67)=1; Ppy( 67)=2;  Ppx( 68)=2; Ppy( 68)=2;
  Ppx( 69)=2; Ppy( 69)=0;  Ppx( 70)=1; Ppy( 70)=1;  Ppx( 71)=2; Ppy( 71)=1;  Ppx( 72)=1; Ppy( 72)=2;
  Ppx( 73)=0; Ppy( 73)=1;  Ppx( 74)=1; Ppy( 74)=1;  Ppx( 75)=1; Ppy( 75)=2;  Ppx( 76)=2; Ppy( 76)=2;
  Ppx( 77)=2; Ppy( 77)=0;  Ppx( 78)=1; Ppy( 78)=1;  Ppx( 79)=2; Ppy( 79)=1;  Ppx( 80)=1; Ppy( 80)=2;

  // PIEZA 6: J
  Ppx( 81)=0; Ppy( 81)=1;  Ppx( 82)=0; Ppy( 82)=2;  Ppx( 83)=1; Ppy( 83)=2;  Ppx( 84)=2; Ppy( 84)=2;
  Ppx( 85)=1; Ppy( 85)=1;  Ppx( 86)=2; Ppy( 86)=1;  Ppx( 87)=1; Ppy( 87)=2;  Ppx( 88)=1; Ppy( 88)=3;
  Ppx( 89)=0; Ppy( 89)=2;  Ppx( 90)=1; Ppy( 90)=2;  Ppx( 91)=2; Ppy( 91)=2;  Ppx( 92)=2; Ppy( 92)=3;
  Ppx( 93)=1; Ppy( 93)=1;  Ppx( 94)=1; Ppy( 94)=2;  Ppx( 95)=0; Ppy( 95)=3;  Ppx( 96)=1; Ppy( 96)=3;

  // PIEZA 7: L
  Ppx( 97)=2; Ppy( 97)=1;  Ppx( 98)=0; Ppy( 98)=2;  Ppx( 99)=1; Ppy( 99)=2;  Ppx(100)=2; Ppy(100)=2;
  Ppx(101)=1; Ppy(101)=1;  Ppx(102)=1; Ppy(102)=2;  Ppx(103)=1; Ppy(103)=3;  Ppx(104)=2; Ppy(104)=3;
  Ppx(105)=0; Ppy(105)=2;  Ppx(106)=1; Ppy(106)=2;  Ppx(107)=2; Ppy(107)=2;  Ppx(108)=0; Ppy(108)=3;
  Ppx(109)=0; Ppy(109)=1;  Ppx(110)=1; Ppy(110)=1;  Ppx(111)=1; Ppy(111)=2;  Ppx(112)=1; Ppy(112)=3;
endsr;
 /end-free